Q. 8번 [ 33184 KB/36 ms ]

1. 문제 분석
- 정육면체 모양의 상자가 일렬로 늘어서 있다. 상자마다 크기가 주어져 있다. 
- 앞에 있는 상자의 크기가 뒤에 있는 상자의 크기보다 작으면, 앞에 있는 상자를 뒤에 있는 상자 안에 넣을 수가 있다.
- 상자의 크기가 주어질 때, 한 번에 넣을 수 있는 최대의 상자 개수를 출력하는 프로그램
- 즉, 가장 긴 증가하는 부분 수열을 찾는 문제


- 입력
  - 첫 번째 줄에 상자의 개수 n이 주어진다.
  - 두 번째 줄에 각 상자의 크기 x가 순서대로 주어진다.

2. 제약조건
- 상자의 개수 n : (1 <= n <= 1,000)
- 상자의 크기 x : (1 <= x <= 1,000)

3. 사용 알고리즘
- DP, LIS

4. 풀이 방법
- 첫번째 풀이 방법 (O(N^2))
- 크기가 N인 DP 배열 : dp[i] = i 번째 값까지 고려했을 경우, 증가하는 부분 수열 중 길이가 가장 긴것의 길이
- dp 배열 초기화 : 1로 초기화 한다.
- 1번부터 N-1번까지 반복문 수행 -> i
  - 0번부터 i-1 번까지 반복문 수행 -> j
    - if i번째 값 > j번째 값 : -> 증가하는 수열
      - i번째 dp 값 갱신 : dp[i] = max(dp[i], dp[j] + i번째 값)


- 두번째 풀이 방법 (O(NlogN))
- LIS 배열에 첫번째 값을 넣어둔다. LIS 배열은 항상 오름차순으로 정렬된 상태를 유지하며 값이 추가된다.
- 1번부터 N-1번까지 반복문 수행 -> i
  - if LIS에서 가장 큰 값(마지막 값) < i번째 값:
    - LIS 에 i번째 값을 추가한다.
  - if LIS에서 가장 큰 값(마지막 값) >= i번째 값:
    - LIS 에 i번째 값이 들어갈 적절한 곳을 찾는다. -> i번째 값보다 크면서 가장 작은 값의 위치
      - 더 효율적인 검색을 위해, 이분 탐색을 활용한다.
    - i번째 값을 해당 위치의 값과 교환한다.
- 최종 정답은 LIS의 길이

5. 어려운 점
- ~