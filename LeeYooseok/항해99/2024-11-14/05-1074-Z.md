Q. 5번 [ 108080 KB/92 ms ]

1. 문제 분석
- N 에 대하여 2^N x 2^N 크기의 배열
- 2 x 2 배열에 대하여 왼쪽 위 -> 오른쪽 위 -> 왼쪽 아래 -> 오른쪽 아래 순서대로 방문한다.
- N > 1인 경우 배열을 크기가 2^(N - 1) x 2^(N - 1)로 4등분 한 후 Z 순서대로 재귀적으로 방문한다.
- N, r, c 가 주어질 때, r행 c열에 몇번째로 방문하는지 확인

- 입력
  - 첫째 줄에 N, r, c

2. 제약조건
- 배열의 크기 N : (1 <= N <= 15)
- 0 <= r, c <= 2^N

3. 사용 알고리즘
- 재귀, 분할

4. 풀이 방법
- 2차원 배열을 구현할 필요가 없음 -> 메모리 제한
- 재귀 풀이(n, now_x, now_y, now_value): -> n 현재 한변의 길이, 현재 위치(now_x, now_y), [now_x][now_y] 의 값
  - n = 1: return now_x, now_y 에 맞는 값
    - 2사분면 : now_value
    - 1사분면 : now_value + 1
    - 3사분면 : now_value + 2
    - 4사분면 : now_value + 3
  - else: 4구역으로 나눔
    - 0 <= now_x < (2 ^ (n-1)) and 0 <= now_y < (2 ^ (n-1)) -> 2사분면
      - now_x, now_y, now_value
    - (2 ^ (n - 1)) <= now_x and 0 <= now_y < (2 ^ (n-1)) -> 1사분면
      - now_x - (2 ^ (n - 1)), now_y, now_value + ((2 ^ (n - 1)) ^ 2)
    - 0 <= now_x < (2 ^ (n-1)) and (2 ^ (n - 1)) <= now_y -> 3사분면
      - now_x, now_y - (2 ^ (n - 1)), now_value + 2 * ((2 ^ (n - 1)) ^ 2)
    - (2 ^ (n-1)) <= now_x and (2 ^ (n - 1)) <= now_y -> 4사분면
      - now_x - (2 ^ (n - 1)), now_y - (2 ^ (n - 1)), now_value + 3 * ((2 ^ (n - 1)) ^ 2)

5. 어려운 점
- ~